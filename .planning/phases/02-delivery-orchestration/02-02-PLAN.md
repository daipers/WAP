---
phase: 02-delivery-orchestration
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - dev_package/src/delivery_service/delivery_api.py
  - dev_package/src/delivery_service/session_manager.py
  - dev_package/src/delivery_service/websocket_handler.py
autonomous: true

must_haves:
  truths:
    - "Candidate can start an assessment session and receive first item"
    - "Timer is server-authoritative; client cannot manipulate"
    - "Candidate can navigate between items (linear or non-linear)"
    - "Candidate can save progress and resume without losing answers"
    - "Server maintains timing even when client disconnects"
  artifacts:
    - path: "dev_package/src/delivery_service/delivery_api.py"
      provides: "FastAPI routes for starting, submitting, navigating assessment"
      exports: ["router", "start_assessment", "submit_answer", "get_current_item", "save_progress"]
    - path: "dev_package/src/delivery_service/session_manager.py"
      provides: "AssessmentSession management with state machine"
      exports: ["AssessmentSession", "SessionManager"]
    - path: "dev_package/src/delivery_service/websocket_handler.py"
      provides: "WebSocket handler for real-time timer sync"
      exports: ["DeliveryWebSocketHandler", "timer_sync"]
  key_links:
    - from: "delivery_api.py"
      to: "test_assembly.py"
      via: "TestAssemblyService.build_test"
      pattern: "test_assembly.*build_test"
    - from: "websocket_handler.py"
      to: "session_manager.py"
      via: "timer sync via get_time_remaining"
      pattern: "session_manager.*time_remaining"
---

<objective>
Build delivery API with FastAPI and WebSocket for real-time assessment delivery, server-authoritative timing, and save/resume functionality.
</objective>

<tasks>

<task type="auto">
  <name>Create AssessmentSession model and SessionManager</name>
  <files>dev_package/src/delivery_service/session_manager.py</files>
  <action>
Create:
- AssessmentSession dataclass: session_id, assessment_definition, candidate_id, state, current_item_index, responses (dict), time_remaining_seconds, started_at, completed_at, items (ordered list)
- SessionManager class: create_session(), get_session(), save_progress(), restore_session(), get_time_remaining(), update_state()

Use python-statemachine patterns from research for state transitions (not_started -> in_progress -> paused -> completed/expired/terminated).
Integrate with existing IdentityService for candidate lookup.
  </action>
  <verify>SessionManager can create session, save progress, restore with answers intact</verify>
  <done>AssessmentSession stores all required fields; SessionManager handles full lifecycle</done>
</task>

<task type="auto">
  <name>Create FastAPI delivery routes</name>
  <files>dev_package/src/delivery_service/delivery_api.py</files>
  <action>
Create FastAPI router with endpoints:
- POST /delivery/start/{assessment_id} - Creates session, returns first item
- GET /delivery/session/{session_id}/current - Returns current item and timer
- POST /delivery/session/{session_id}/answer - Records answer for current item
- POST /delivery/session/{session_id}/navigate - Move to next/previous/specific item
- POST /delivery/session/{session_id}/save - Explicit save progress
- POST /delivery/session/{session_id}/submit - Complete assessment

All routes return appropriate responses including timer sync info. Use dependency injection for SessionManager.
  </action>
  <verify>Routes respond with correct status codes and data</verify>
  <done>All 6 endpoints functional with proper request/response schemas</done>
</task>

<task type="auto">
  <name>Implement WebSocket timer handler</name>
  <files>dev_package/src/delivery_service/websocket_handler.py</files>
  <action>
Create DeliveryWebSocketHandler that:
- accept_connection(session_id): validates session exists
- handle_message(data): processes answer_save, navigate, ping types
- timer_sync(): sends timer updates every second to client
- handle_disconnect(): logs disconnect, updates session state

Server calculates time_remaining from session start time + config; client only receives. On disconnect, session remains active (timer continues server-side).

Pattern: Use asyncio.sleep(1) for timer broadcast loop.
  </action>
  <verify>WebSocket accepts connection and sends timer updates</verify>
  <done>Timer sync works; client receives time updates every second</done>
</task>

</tasks>

<verification>
- Can start assessment and receive first item
- Timer counts down server-side; client display synced
- Save progress preserves all answers
- Resume restores exact position and time remaining
- Disconnect does not pause timer
</verification>

<success_criteria>
Candidate can take assessment with timed, navigable interface; progress saves and resumes correctly; server maintains authoritative timing.
</success_criteria>

<output>
After completion, create `.planning/phases/02-delivery-orchestration/02-02-SUMMARY.md`
</output>
